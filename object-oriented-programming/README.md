# 객체 지향 프로그래밍

## 디자인 패턴
|패턴명|설명|사용방식|장점|단점|
|--|--|--|--|--|
|Singleton|프로그램 전체에서 딱 하나만, 공통으로 존재하는 객체|static한 class 객체를 선언해서 사용|공통적인 내용 저장하면서, 상속/인터페이스 등의 객체개념까지 가능|멀티스레드 환경에서 위험성|
|Strategy|유사한 패턴과 기능을 가지지만 서로 다른 target을 대상으로 하는 요소에, target을 갈아끼울 수 있도록 모듈화 하는 방식|기능별로 Class를 구현해서 호출한다|||
|State|같은 객체가 상태에 따라 동작이 달라질 때, 각 상태별 동작을 모듈화하는 방식 |||
|Command|유사한 패턴을 가지지만 다른 기능과 target을 대상으로 하는 요소에, 모듈화하는 방식||최상위 Command 추상클래스를 만들고,이를 상속받는 커맨드별 class를 정의|
|Adaptor|인터페이스가 다른 객체들이 같은 방식으로 작동할 수 있게 연결|Adaptor 클래스를 만들어서, 객체들이 통일된 메소드명으로 wrap해줌||
|Proxy(대리인)|무거운 클래스를 호출해야할 필요가 있을 때, 해당 클래스의 일부 기능을 수행하는 가벼운 대리인 클래스를 만들어 대신 나가게 하는 방법|동일한 Proxy 인터페이스를 정의한 후, 무거운 클래스를 정의하고, 가벼운 클래스 내에서 무거운 클래스를 선언해꼭 필요한 상황에 맞게 호출해서 쓴다||
|Facade(외벽)|여러 클래스 객체를 순차적으로 사용할 때,절차를 하나로 묶어서 은닉화하는 패턴||||
|Template-method|여러 클래스를 순차적으로 사용하는 절차가 공통적으로 존재하되, 세부적으로 서로 다른 부분이 존재할 때 사용하는 패턴|부모 추상 클래스를 만들고, 절차별로 다른 자식 Class를 구현한다|||
|Decorator|특정 클래스의 앞/뒤에 추가적인 동작을 추가하는 패턴|객체를 다른 객체의 생성자 안에 넣어서, 동일한 메소드에 행동을 추가할 수 있음|||
|Factory-method|객체를 조건 등에 따라 다르게 생성하는 경우, 팩토리를 통해 생성하는 방식||변경에 강해짐, 클래스에 대해 알 필요가 없음||
|Abstract-factory|Factory-method에서, 팩토리조차 추상화해서 생성하는 방식|팩토리 추상 클래스를 만든 후, 필요에 따라 다르게 팩토리 자식 클래스를 만든다|||
|Mediator(중개자)|특정 클래스가 다른 클래스와 연결된 경우, 해당 클래스의 변경을 다른 클래스에 전달하기 위한 패턴|Mediator Listener 객체 생성, 각 클래스간의 연결관계를 내부에 저장. 원본 클래스가 바뀌면, mediator listener객체에게 변경 요청|||
|Composite|포함하는 것과 포함되는 객체들이, 동일한 기능을 갖는 경우(예시 : 파일시스템)|객체 내에, 자기자신의 타입을 제네릭으로 갖는 list 생성 ||| 
